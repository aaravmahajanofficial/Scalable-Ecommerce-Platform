// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package repository

import (
	"context"

	"github.com/aaravmahajanofficial/scalable-ecommerce-platform/internal/models"
	"github.com/google/uuid"
	mock "github.com/stretchr/testify/mock"
)

// NewMockCartRepository creates a new instance of MockCartRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockCartRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockCartRepository {
	mock := &MockCartRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockCartRepository is an autogenerated mock type for the CartRepository type
type MockCartRepository struct {
	mock.Mock
}

type MockCartRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockCartRepository) EXPECT() *MockCartRepository_Expecter {
	return &MockCartRepository_Expecter{mock: &_m.Mock}
}

// CreateCart provides a mock function for the type MockCartRepository
func (_mock *MockCartRepository) CreateCart(ctx context.Context, cart *models.Cart) error {
	ret := _mock.Called(ctx, cart)

	if len(ret) == 0 {
		panic("no return value specified for CreateCart")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *models.Cart) error); ok {
		r0 = returnFunc(ctx, cart)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockCartRepository_CreateCart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCart'
type MockCartRepository_CreateCart_Call struct {
	*mock.Call
}

// CreateCart is a helper method to define mock.On call
//   - ctx
//   - cart
func (_e *MockCartRepository_Expecter) CreateCart(ctx interface{}, cart interface{}) *MockCartRepository_CreateCart_Call {
	return &MockCartRepository_CreateCart_Call{Call: _e.mock.On("CreateCart", ctx, cart)}
}

func (_c *MockCartRepository_CreateCart_Call) Run(run func(ctx context.Context, cart *models.Cart)) *MockCartRepository_CreateCart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Cart))
	})
	return _c
}

func (_c *MockCartRepository_CreateCart_Call) Return(err error) *MockCartRepository_CreateCart_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockCartRepository_CreateCart_Call) RunAndReturn(run func(ctx context.Context, cart *models.Cart) error) *MockCartRepository_CreateCart_Call {
	_c.Call.Return(run)
	return _c
}

// GetCartByCustomerID provides a mock function for the type MockCartRepository
func (_mock *MockCartRepository) GetCartByCustomerID(ctx context.Context, customerID uuid.UUID) (*models.Cart, error) {
	ret := _mock.Called(ctx, customerID)

	if len(ret) == 0 {
		panic("no return value specified for GetCartByCustomerID")
	}

	var r0 *models.Cart
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*models.Cart, error)); ok {
		return returnFunc(ctx, customerID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *models.Cart); ok {
		r0 = returnFunc(ctx, customerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Cart)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, customerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockCartRepository_GetCartByCustomerID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCartByCustomerID'
type MockCartRepository_GetCartByCustomerID_Call struct {
	*mock.Call
}

// GetCartByCustomerID is a helper method to define mock.On call
//   - ctx
//   - customerID
func (_e *MockCartRepository_Expecter) GetCartByCustomerID(ctx interface{}, customerID interface{}) *MockCartRepository_GetCartByCustomerID_Call {
	return &MockCartRepository_GetCartByCustomerID_Call{Call: _e.mock.On("GetCartByCustomerID", ctx, customerID)}
}

func (_c *MockCartRepository_GetCartByCustomerID_Call) Run(run func(ctx context.Context, customerID uuid.UUID)) *MockCartRepository_GetCartByCustomerID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockCartRepository_GetCartByCustomerID_Call) Return(cart *models.Cart, err error) *MockCartRepository_GetCartByCustomerID_Call {
	_c.Call.Return(cart, err)
	return _c
}

func (_c *MockCartRepository_GetCartByCustomerID_Call) RunAndReturn(run func(ctx context.Context, customerID uuid.UUID) (*models.Cart, error)) *MockCartRepository_GetCartByCustomerID_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateCart provides a mock function for the type MockCartRepository
func (_mock *MockCartRepository) UpdateCart(ctx context.Context, cart *models.Cart) error {
	ret := _mock.Called(ctx, cart)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCart")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *models.Cart) error); ok {
		r0 = returnFunc(ctx, cart)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockCartRepository_UpdateCart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateCart'
type MockCartRepository_UpdateCart_Call struct {
	*mock.Call
}

// UpdateCart is a helper method to define mock.On call
//   - ctx
//   - cart
func (_e *MockCartRepository_Expecter) UpdateCart(ctx interface{}, cart interface{}) *MockCartRepository_UpdateCart_Call {
	return &MockCartRepository_UpdateCart_Call{Call: _e.mock.On("UpdateCart", ctx, cart)}
}

func (_c *MockCartRepository_UpdateCart_Call) Run(run func(ctx context.Context, cart *models.Cart)) *MockCartRepository_UpdateCart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Cart))
	})
	return _c
}

func (_c *MockCartRepository_UpdateCart_Call) Return(err error) *MockCartRepository_UpdateCart_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockCartRepository_UpdateCart_Call) RunAndReturn(run func(ctx context.Context, cart *models.Cart) error) *MockCartRepository_UpdateCart_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockNotificationRepository creates a new instance of MockNotificationRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockNotificationRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockNotificationRepository {
	mock := &MockNotificationRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockNotificationRepository is an autogenerated mock type for the NotificationRepository type
type MockNotificationRepository struct {
	mock.Mock
}

type MockNotificationRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockNotificationRepository) EXPECT() *MockNotificationRepository_Expecter {
	return &MockNotificationRepository_Expecter{mock: &_m.Mock}
}

// CreateNotification provides a mock function for the type MockNotificationRepository
func (_mock *MockNotificationRepository) CreateNotification(ctx context.Context, notification *models.Notification) error {
	ret := _mock.Called(ctx, notification)

	if len(ret) == 0 {
		panic("no return value specified for CreateNotification")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *models.Notification) error); ok {
		r0 = returnFunc(ctx, notification)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockNotificationRepository_CreateNotification_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateNotification'
type MockNotificationRepository_CreateNotification_Call struct {
	*mock.Call
}

// CreateNotification is a helper method to define mock.On call
//   - ctx
//   - notification
func (_e *MockNotificationRepository_Expecter) CreateNotification(ctx interface{}, notification interface{}) *MockNotificationRepository_CreateNotification_Call {
	return &MockNotificationRepository_CreateNotification_Call{Call: _e.mock.On("CreateNotification", ctx, notification)}
}

func (_c *MockNotificationRepository_CreateNotification_Call) Run(run func(ctx context.Context, notification *models.Notification)) *MockNotificationRepository_CreateNotification_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Notification))
	})
	return _c
}

func (_c *MockNotificationRepository_CreateNotification_Call) Return(err error) *MockNotificationRepository_CreateNotification_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockNotificationRepository_CreateNotification_Call) RunAndReturn(run func(ctx context.Context, notification *models.Notification) error) *MockNotificationRepository_CreateNotification_Call {
	_c.Call.Return(run)
	return _c
}

// GetNotificationById provides a mock function for the type MockNotificationRepository
func (_mock *MockNotificationRepository) GetNotificationById(ctx context.Context, id uuid.UUID) (*models.Notification, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetNotificationById")
	}

	var r0 *models.Notification
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*models.Notification, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *models.Notification); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Notification)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockNotificationRepository_GetNotificationById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNotificationById'
type MockNotificationRepository_GetNotificationById_Call struct {
	*mock.Call
}

// GetNotificationById is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *MockNotificationRepository_Expecter) GetNotificationById(ctx interface{}, id interface{}) *MockNotificationRepository_GetNotificationById_Call {
	return &MockNotificationRepository_GetNotificationById_Call{Call: _e.mock.On("GetNotificationById", ctx, id)}
}

func (_c *MockNotificationRepository_GetNotificationById_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockNotificationRepository_GetNotificationById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockNotificationRepository_GetNotificationById_Call) Return(notification *models.Notification, err error) *MockNotificationRepository_GetNotificationById_Call {
	_c.Call.Return(notification, err)
	return _c
}

func (_c *MockNotificationRepository_GetNotificationById_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (*models.Notification, error)) *MockNotificationRepository_GetNotificationById_Call {
	_c.Call.Return(run)
	return _c
}

// ListNotifications provides a mock function for the type MockNotificationRepository
func (_mock *MockNotificationRepository) ListNotifications(ctx context.Context, page int, size int) ([]*models.Notification, int, error) {
	ret := _mock.Called(ctx, page, size)

	if len(ret) == 0 {
		panic("no return value specified for ListNotifications")
	}

	var r0 []*models.Notification
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int) ([]*models.Notification, int, error)); ok {
		return returnFunc(ctx, page, size)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int) []*models.Notification); ok {
		r0 = returnFunc(ctx, page, size)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Notification)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int, int) int); ok {
		r1 = returnFunc(ctx, page, size)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, int, int) error); ok {
		r2 = returnFunc(ctx, page, size)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockNotificationRepository_ListNotifications_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListNotifications'
type MockNotificationRepository_ListNotifications_Call struct {
	*mock.Call
}

// ListNotifications is a helper method to define mock.On call
//   - ctx
//   - page
//   - size
func (_e *MockNotificationRepository_Expecter) ListNotifications(ctx interface{}, page interface{}, size interface{}) *MockNotificationRepository_ListNotifications_Call {
	return &MockNotificationRepository_ListNotifications_Call{Call: _e.mock.On("ListNotifications", ctx, page, size)}
}

func (_c *MockNotificationRepository_ListNotifications_Call) Run(run func(ctx context.Context, page int, size int)) *MockNotificationRepository_ListNotifications_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockNotificationRepository_ListNotifications_Call) Return(notifications []*models.Notification, n int, err error) *MockNotificationRepository_ListNotifications_Call {
	_c.Call.Return(notifications, n, err)
	return _c
}

func (_c *MockNotificationRepository_ListNotifications_Call) RunAndReturn(run func(ctx context.Context, page int, size int) ([]*models.Notification, int, error)) *MockNotificationRepository_ListNotifications_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateNotificationStatus provides a mock function for the type MockNotificationRepository
func (_mock *MockNotificationRepository) UpdateNotificationStatus(ctx context.Context, id uuid.UUID, status models.NotificationStatus, errorMsg string) error {
	ret := _mock.Called(ctx, id, status, errorMsg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateNotificationStatus")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, models.NotificationStatus, string) error); ok {
		r0 = returnFunc(ctx, id, status, errorMsg)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockNotificationRepository_UpdateNotificationStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateNotificationStatus'
type MockNotificationRepository_UpdateNotificationStatus_Call struct {
	*mock.Call
}

// UpdateNotificationStatus is a helper method to define mock.On call
//   - ctx
//   - id
//   - status
//   - errorMsg
func (_e *MockNotificationRepository_Expecter) UpdateNotificationStatus(ctx interface{}, id interface{}, status interface{}, errorMsg interface{}) *MockNotificationRepository_UpdateNotificationStatus_Call {
	return &MockNotificationRepository_UpdateNotificationStatus_Call{Call: _e.mock.On("UpdateNotificationStatus", ctx, id, status, errorMsg)}
}

func (_c *MockNotificationRepository_UpdateNotificationStatus_Call) Run(run func(ctx context.Context, id uuid.UUID, status models.NotificationStatus, errorMsg string)) *MockNotificationRepository_UpdateNotificationStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(models.NotificationStatus), args[3].(string))
	})
	return _c
}

func (_c *MockNotificationRepository_UpdateNotificationStatus_Call) Return(err error) *MockNotificationRepository_UpdateNotificationStatus_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockNotificationRepository_UpdateNotificationStatus_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID, status models.NotificationStatus, errorMsg string) error) *MockNotificationRepository_UpdateNotificationStatus_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockOrderRepository creates a new instance of MockOrderRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockOrderRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockOrderRepository {
	mock := &MockOrderRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockOrderRepository is an autogenerated mock type for the OrderRepository type
type MockOrderRepository struct {
	mock.Mock
}

type MockOrderRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockOrderRepository) EXPECT() *MockOrderRepository_Expecter {
	return &MockOrderRepository_Expecter{mock: &_m.Mock}
}

// CreateOrder provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) CreateOrder(ctx context.Context, order *models.Order) error {
	ret := _mock.Called(ctx, order)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrder")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *models.Order) error); ok {
		r0 = returnFunc(ctx, order)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockOrderRepository_CreateOrder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrder'
type MockOrderRepository_CreateOrder_Call struct {
	*mock.Call
}

// CreateOrder is a helper method to define mock.On call
//   - ctx
//   - order
func (_e *MockOrderRepository_Expecter) CreateOrder(ctx interface{}, order interface{}) *MockOrderRepository_CreateOrder_Call {
	return &MockOrderRepository_CreateOrder_Call{Call: _e.mock.On("CreateOrder", ctx, order)}
}

func (_c *MockOrderRepository_CreateOrder_Call) Run(run func(ctx context.Context, order *models.Order)) *MockOrderRepository_CreateOrder_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Order))
	})
	return _c
}

func (_c *MockOrderRepository_CreateOrder_Call) Return(err error) *MockOrderRepository_CreateOrder_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockOrderRepository_CreateOrder_Call) RunAndReturn(run func(ctx context.Context, order *models.Order) error) *MockOrderRepository_CreateOrder_Call {
	_c.Call.Return(run)
	return _c
}

// GetOrderById provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) GetOrderById(ctx context.Context, id uuid.UUID) (*models.Order, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetOrderById")
	}

	var r0 *models.Order
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*models.Order, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *models.Order); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Order)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOrderRepository_GetOrderById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOrderById'
type MockOrderRepository_GetOrderById_Call struct {
	*mock.Call
}

// GetOrderById is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *MockOrderRepository_Expecter) GetOrderById(ctx interface{}, id interface{}) *MockOrderRepository_GetOrderById_Call {
	return &MockOrderRepository_GetOrderById_Call{Call: _e.mock.On("GetOrderById", ctx, id)}
}

func (_c *MockOrderRepository_GetOrderById_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockOrderRepository_GetOrderById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockOrderRepository_GetOrderById_Call) Return(order *models.Order, err error) *MockOrderRepository_GetOrderById_Call {
	_c.Call.Return(order, err)
	return _c
}

func (_c *MockOrderRepository_GetOrderById_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (*models.Order, error)) *MockOrderRepository_GetOrderById_Call {
	_c.Call.Return(run)
	return _c
}

// ListOrdersByCustomer provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) ListOrdersByCustomer(ctx context.Context, customerID uuid.UUID, page int, size int) ([]models.Order, int, error) {
	ret := _mock.Called(ctx, customerID, page, size)

	if len(ret) == 0 {
		panic("no return value specified for ListOrdersByCustomer")
	}

	var r0 []models.Order
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, int, int) ([]models.Order, int, error)); ok {
		return returnFunc(ctx, customerID, page, size)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, int, int) []models.Order); ok {
		r0 = returnFunc(ctx, customerID, page, size)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Order)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID, int, int) int); ok {
		r1 = returnFunc(ctx, customerID, page, size)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, uuid.UUID, int, int) error); ok {
		r2 = returnFunc(ctx, customerID, page, size)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockOrderRepository_ListOrdersByCustomer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListOrdersByCustomer'
type MockOrderRepository_ListOrdersByCustomer_Call struct {
	*mock.Call
}

// ListOrdersByCustomer is a helper method to define mock.On call
//   - ctx
//   - customerID
//   - page
//   - size
func (_e *MockOrderRepository_Expecter) ListOrdersByCustomer(ctx interface{}, customerID interface{}, page interface{}, size interface{}) *MockOrderRepository_ListOrdersByCustomer_Call {
	return &MockOrderRepository_ListOrdersByCustomer_Call{Call: _e.mock.On("ListOrdersByCustomer", ctx, customerID, page, size)}
}

func (_c *MockOrderRepository_ListOrdersByCustomer_Call) Run(run func(ctx context.Context, customerID uuid.UUID, page int, size int)) *MockOrderRepository_ListOrdersByCustomer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *MockOrderRepository_ListOrdersByCustomer_Call) Return(orders []models.Order, n int, err error) *MockOrderRepository_ListOrdersByCustomer_Call {
	_c.Call.Return(orders, n, err)
	return _c
}

func (_c *MockOrderRepository_ListOrdersByCustomer_Call) RunAndReturn(run func(ctx context.Context, customerID uuid.UUID, page int, size int) ([]models.Order, int, error)) *MockOrderRepository_ListOrdersByCustomer_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateOrderStatus provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) UpdateOrderStatus(ctx context.Context, id uuid.UUID, status models.OrderStatus) (*models.Order, error) {
	ret := _mock.Called(ctx, id, status)

	if len(ret) == 0 {
		panic("no return value specified for UpdateOrderStatus")
	}

	var r0 *models.Order
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, models.OrderStatus) (*models.Order, error)); ok {
		return returnFunc(ctx, id, status)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, models.OrderStatus) *models.Order); ok {
		r0 = returnFunc(ctx, id, status)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Order)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID, models.OrderStatus) error); ok {
		r1 = returnFunc(ctx, id, status)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOrderRepository_UpdateOrderStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateOrderStatus'
type MockOrderRepository_UpdateOrderStatus_Call struct {
	*mock.Call
}

// UpdateOrderStatus is a helper method to define mock.On call
//   - ctx
//   - id
//   - status
func (_e *MockOrderRepository_Expecter) UpdateOrderStatus(ctx interface{}, id interface{}, status interface{}) *MockOrderRepository_UpdateOrderStatus_Call {
	return &MockOrderRepository_UpdateOrderStatus_Call{Call: _e.mock.On("UpdateOrderStatus", ctx, id, status)}
}

func (_c *MockOrderRepository_UpdateOrderStatus_Call) Run(run func(ctx context.Context, id uuid.UUID, status models.OrderStatus)) *MockOrderRepository_UpdateOrderStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(models.OrderStatus))
	})
	return _c
}

func (_c *MockOrderRepository_UpdateOrderStatus_Call) Return(order *models.Order, err error) *MockOrderRepository_UpdateOrderStatus_Call {
	_c.Call.Return(order, err)
	return _c
}

func (_c *MockOrderRepository_UpdateOrderStatus_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID, status models.OrderStatus) (*models.Order, error)) *MockOrderRepository_UpdateOrderStatus_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePaymentStatus provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) UpdatePaymentStatus(ctx context.Context, id uuid.UUID, status models.PaymentStatus, paymentIntentID string) error {
	ret := _mock.Called(ctx, id, status, paymentIntentID)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePaymentStatus")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, models.PaymentStatus, string) error); ok {
		r0 = returnFunc(ctx, id, status, paymentIntentID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockOrderRepository_UpdatePaymentStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePaymentStatus'
type MockOrderRepository_UpdatePaymentStatus_Call struct {
	*mock.Call
}

// UpdatePaymentStatus is a helper method to define mock.On call
//   - ctx
//   - id
//   - status
//   - paymentIntentID
func (_e *MockOrderRepository_Expecter) UpdatePaymentStatus(ctx interface{}, id interface{}, status interface{}, paymentIntentID interface{}) *MockOrderRepository_UpdatePaymentStatus_Call {
	return &MockOrderRepository_UpdatePaymentStatus_Call{Call: _e.mock.On("UpdatePaymentStatus", ctx, id, status, paymentIntentID)}
}

func (_c *MockOrderRepository_UpdatePaymentStatus_Call) Run(run func(ctx context.Context, id uuid.UUID, status models.PaymentStatus, paymentIntentID string)) *MockOrderRepository_UpdatePaymentStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(models.PaymentStatus), args[3].(string))
	})
	return _c
}

func (_c *MockOrderRepository_UpdatePaymentStatus_Call) Return(err error) *MockOrderRepository_UpdatePaymentStatus_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockOrderRepository_UpdatePaymentStatus_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID, status models.PaymentStatus, paymentIntentID string) error) *MockOrderRepository_UpdatePaymentStatus_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockPaymentRepository creates a new instance of MockPaymentRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPaymentRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockPaymentRepository {
	mock := &MockPaymentRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockPaymentRepository is an autogenerated mock type for the PaymentRepository type
type MockPaymentRepository struct {
	mock.Mock
}

type MockPaymentRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockPaymentRepository) EXPECT() *MockPaymentRepository_Expecter {
	return &MockPaymentRepository_Expecter{mock: &_m.Mock}
}

// CreatePayment provides a mock function for the type MockPaymentRepository
func (_mock *MockPaymentRepository) CreatePayment(ctx context.Context, payment *models.Payment) error {
	ret := _mock.Called(ctx, payment)

	if len(ret) == 0 {
		panic("no return value specified for CreatePayment")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *models.Payment) error); ok {
		r0 = returnFunc(ctx, payment)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPaymentRepository_CreatePayment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePayment'
type MockPaymentRepository_CreatePayment_Call struct {
	*mock.Call
}

// CreatePayment is a helper method to define mock.On call
//   - ctx
//   - payment
func (_e *MockPaymentRepository_Expecter) CreatePayment(ctx interface{}, payment interface{}) *MockPaymentRepository_CreatePayment_Call {
	return &MockPaymentRepository_CreatePayment_Call{Call: _e.mock.On("CreatePayment", ctx, payment)}
}

func (_c *MockPaymentRepository_CreatePayment_Call) Run(run func(ctx context.Context, payment *models.Payment)) *MockPaymentRepository_CreatePayment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Payment))
	})
	return _c
}

func (_c *MockPaymentRepository_CreatePayment_Call) Return(err error) *MockPaymentRepository_CreatePayment_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPaymentRepository_CreatePayment_Call) RunAndReturn(run func(ctx context.Context, payment *models.Payment) error) *MockPaymentRepository_CreatePayment_Call {
	_c.Call.Return(run)
	return _c
}

// GetPaymentByID provides a mock function for the type MockPaymentRepository
func (_mock *MockPaymentRepository) GetPaymentByID(ctx context.Context, id string) (*models.Payment, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetPaymentByID")
	}

	var r0 *models.Payment
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*models.Payment, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *models.Payment); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Payment)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPaymentRepository_GetPaymentByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPaymentByID'
type MockPaymentRepository_GetPaymentByID_Call struct {
	*mock.Call
}

// GetPaymentByID is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *MockPaymentRepository_Expecter) GetPaymentByID(ctx interface{}, id interface{}) *MockPaymentRepository_GetPaymentByID_Call {
	return &MockPaymentRepository_GetPaymentByID_Call{Call: _e.mock.On("GetPaymentByID", ctx, id)}
}

func (_c *MockPaymentRepository_GetPaymentByID_Call) Run(run func(ctx context.Context, id string)) *MockPaymentRepository_GetPaymentByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPaymentRepository_GetPaymentByID_Call) Return(payment *models.Payment, err error) *MockPaymentRepository_GetPaymentByID_Call {
	_c.Call.Return(payment, err)
	return _c
}

func (_c *MockPaymentRepository_GetPaymentByID_Call) RunAndReturn(run func(ctx context.Context, id string) (*models.Payment, error)) *MockPaymentRepository_GetPaymentByID_Call {
	_c.Call.Return(run)
	return _c
}

// ListPaymentsOfCustomer provides a mock function for the type MockPaymentRepository
func (_mock *MockPaymentRepository) ListPaymentsOfCustomer(ctx context.Context, customerID string, page int, size int) ([]*models.Payment, int, error) {
	ret := _mock.Called(ctx, customerID, page, size)

	if len(ret) == 0 {
		panic("no return value specified for ListPaymentsOfCustomer")
	}

	var r0 []*models.Payment
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int, int) ([]*models.Payment, int, error)); ok {
		return returnFunc(ctx, customerID, page, size)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int, int) []*models.Payment); ok {
		r0 = returnFunc(ctx, customerID, page, size)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Payment)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, int, int) int); ok {
		r1 = returnFunc(ctx, customerID, page, size)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, int, int) error); ok {
		r2 = returnFunc(ctx, customerID, page, size)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockPaymentRepository_ListPaymentsOfCustomer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPaymentsOfCustomer'
type MockPaymentRepository_ListPaymentsOfCustomer_Call struct {
	*mock.Call
}

// ListPaymentsOfCustomer is a helper method to define mock.On call
//   - ctx
//   - customerID
//   - page
//   - size
func (_e *MockPaymentRepository_Expecter) ListPaymentsOfCustomer(ctx interface{}, customerID interface{}, page interface{}, size interface{}) *MockPaymentRepository_ListPaymentsOfCustomer_Call {
	return &MockPaymentRepository_ListPaymentsOfCustomer_Call{Call: _e.mock.On("ListPaymentsOfCustomer", ctx, customerID, page, size)}
}

func (_c *MockPaymentRepository_ListPaymentsOfCustomer_Call) Run(run func(ctx context.Context, customerID string, page int, size int)) *MockPaymentRepository_ListPaymentsOfCustomer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *MockPaymentRepository_ListPaymentsOfCustomer_Call) Return(payments []*models.Payment, n int, err error) *MockPaymentRepository_ListPaymentsOfCustomer_Call {
	_c.Call.Return(payments, n, err)
	return _c
}

func (_c *MockPaymentRepository_ListPaymentsOfCustomer_Call) RunAndReturn(run func(ctx context.Context, customerID string, page int, size int) ([]*models.Payment, int, error)) *MockPaymentRepository_ListPaymentsOfCustomer_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePaymentStatus provides a mock function for the type MockPaymentRepository
func (_mock *MockPaymentRepository) UpdatePaymentStatus(ctx context.Context, id string, status models.PaymentStatus) error {
	ret := _mock.Called(ctx, id, status)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePaymentStatus")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, models.PaymentStatus) error); ok {
		r0 = returnFunc(ctx, id, status)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPaymentRepository_UpdatePaymentStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePaymentStatus'
type MockPaymentRepository_UpdatePaymentStatus_Call struct {
	*mock.Call
}

// UpdatePaymentStatus is a helper method to define mock.On call
//   - ctx
//   - id
//   - status
func (_e *MockPaymentRepository_Expecter) UpdatePaymentStatus(ctx interface{}, id interface{}, status interface{}) *MockPaymentRepository_UpdatePaymentStatus_Call {
	return &MockPaymentRepository_UpdatePaymentStatus_Call{Call: _e.mock.On("UpdatePaymentStatus", ctx, id, status)}
}

func (_c *MockPaymentRepository_UpdatePaymentStatus_Call) Run(run func(ctx context.Context, id string, status models.PaymentStatus)) *MockPaymentRepository_UpdatePaymentStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(models.PaymentStatus))
	})
	return _c
}

func (_c *MockPaymentRepository_UpdatePaymentStatus_Call) Return(err error) *MockPaymentRepository_UpdatePaymentStatus_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPaymentRepository_UpdatePaymentStatus_Call) RunAndReturn(run func(ctx context.Context, id string, status models.PaymentStatus) error) *MockPaymentRepository_UpdatePaymentStatus_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockProductRepository creates a new instance of MockProductRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProductRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockProductRepository {
	mock := &MockProductRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockProductRepository is an autogenerated mock type for the ProductRepository type
type MockProductRepository struct {
	mock.Mock
}

type MockProductRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockProductRepository) EXPECT() *MockProductRepository_Expecter {
	return &MockProductRepository_Expecter{mock: &_m.Mock}
}

// CreateProduct provides a mock function for the type MockProductRepository
func (_mock *MockProductRepository) CreateProduct(ctx context.Context, product *models.Product) error {
	ret := _mock.Called(ctx, product)

	if len(ret) == 0 {
		panic("no return value specified for CreateProduct")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *models.Product) error); ok {
		r0 = returnFunc(ctx, product)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockProductRepository_CreateProduct_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateProduct'
type MockProductRepository_CreateProduct_Call struct {
	*mock.Call
}

// CreateProduct is a helper method to define mock.On call
//   - ctx
//   - product
func (_e *MockProductRepository_Expecter) CreateProduct(ctx interface{}, product interface{}) *MockProductRepository_CreateProduct_Call {
	return &MockProductRepository_CreateProduct_Call{Call: _e.mock.On("CreateProduct", ctx, product)}
}

func (_c *MockProductRepository_CreateProduct_Call) Run(run func(ctx context.Context, product *models.Product)) *MockProductRepository_CreateProduct_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Product))
	})
	return _c
}

func (_c *MockProductRepository_CreateProduct_Call) Return(err error) *MockProductRepository_CreateProduct_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockProductRepository_CreateProduct_Call) RunAndReturn(run func(ctx context.Context, product *models.Product) error) *MockProductRepository_CreateProduct_Call {
	_c.Call.Return(run)
	return _c
}

// GetProductByID provides a mock function for the type MockProductRepository
func (_mock *MockProductRepository) GetProductByID(ctx context.Context, id uuid.UUID) (*models.Product, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetProductByID")
	}

	var r0 *models.Product
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*models.Product, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *models.Product); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Product)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProductRepository_GetProductByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProductByID'
type MockProductRepository_GetProductByID_Call struct {
	*mock.Call
}

// GetProductByID is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *MockProductRepository_Expecter) GetProductByID(ctx interface{}, id interface{}) *MockProductRepository_GetProductByID_Call {
	return &MockProductRepository_GetProductByID_Call{Call: _e.mock.On("GetProductByID", ctx, id)}
}

func (_c *MockProductRepository_GetProductByID_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockProductRepository_GetProductByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockProductRepository_GetProductByID_Call) Return(product *models.Product, err error) *MockProductRepository_GetProductByID_Call {
	_c.Call.Return(product, err)
	return _c
}

func (_c *MockProductRepository_GetProductByID_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (*models.Product, error)) *MockProductRepository_GetProductByID_Call {
	_c.Call.Return(run)
	return _c
}

// ListProducts provides a mock function for the type MockProductRepository
func (_mock *MockProductRepository) ListProducts(ctx context.Context, page int, size int) ([]*models.Product, int, error) {
	ret := _mock.Called(ctx, page, size)

	if len(ret) == 0 {
		panic("no return value specified for ListProducts")
	}

	var r0 []*models.Product
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int) ([]*models.Product, int, error)); ok {
		return returnFunc(ctx, page, size)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int) []*models.Product); ok {
		r0 = returnFunc(ctx, page, size)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Product)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int, int) int); ok {
		r1 = returnFunc(ctx, page, size)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, int, int) error); ok {
		r2 = returnFunc(ctx, page, size)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockProductRepository_ListProducts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProducts'
type MockProductRepository_ListProducts_Call struct {
	*mock.Call
}

// ListProducts is a helper method to define mock.On call
//   - ctx
//   - page
//   - size
func (_e *MockProductRepository_Expecter) ListProducts(ctx interface{}, page interface{}, size interface{}) *MockProductRepository_ListProducts_Call {
	return &MockProductRepository_ListProducts_Call{Call: _e.mock.On("ListProducts", ctx, page, size)}
}

func (_c *MockProductRepository_ListProducts_Call) Run(run func(ctx context.Context, page int, size int)) *MockProductRepository_ListProducts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockProductRepository_ListProducts_Call) Return(products []*models.Product, n int, err error) *MockProductRepository_ListProducts_Call {
	_c.Call.Return(products, n, err)
	return _c
}

func (_c *MockProductRepository_ListProducts_Call) RunAndReturn(run func(ctx context.Context, page int, size int) ([]*models.Product, int, error)) *MockProductRepository_ListProducts_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateProduct provides a mock function for the type MockProductRepository
func (_mock *MockProductRepository) UpdateProduct(ctx context.Context, product *models.Product) error {
	ret := _mock.Called(ctx, product)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProduct")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *models.Product) error); ok {
		r0 = returnFunc(ctx, product)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockProductRepository_UpdateProduct_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateProduct'
type MockProductRepository_UpdateProduct_Call struct {
	*mock.Call
}

// UpdateProduct is a helper method to define mock.On call
//   - ctx
//   - product
func (_e *MockProductRepository_Expecter) UpdateProduct(ctx interface{}, product interface{}) *MockProductRepository_UpdateProduct_Call {
	return &MockProductRepository_UpdateProduct_Call{Call: _e.mock.On("UpdateProduct", ctx, product)}
}

func (_c *MockProductRepository_UpdateProduct_Call) Run(run func(ctx context.Context, product *models.Product)) *MockProductRepository_UpdateProduct_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Product))
	})
	return _c
}

func (_c *MockProductRepository_UpdateProduct_Call) Return(err error) *MockProductRepository_UpdateProduct_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockProductRepository_UpdateProduct_Call) RunAndReturn(run func(ctx context.Context, product *models.Product) error) *MockProductRepository_UpdateProduct_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockRateLimitRepository creates a new instance of MockRateLimitRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRateLimitRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockRateLimitRepository {
	mock := &MockRateLimitRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockRateLimitRepository is an autogenerated mock type for the RateLimitRepository type
type MockRateLimitRepository struct {
	mock.Mock
}

type MockRateLimitRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockRateLimitRepository) EXPECT() *MockRateLimitRepository_Expecter {
	return &MockRateLimitRepository_Expecter{mock: &_m.Mock}
}

// CheckLoginRateLimit provides a mock function for the type MockRateLimitRepository
func (_mock *MockRateLimitRepository) CheckLoginRateLimit(ctx context.Context, username string) (bool, int, int, error) {
	ret := _mock.Called(ctx, username)

	if len(ret) == 0 {
		panic("no return value specified for CheckLoginRateLimit")
	}

	var r0 bool
	var r1 int
	var r2 int
	var r3 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (bool, int, int, error)); ok {
		return returnFunc(ctx, username)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = returnFunc(ctx, username)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) int); ok {
		r1 = returnFunc(ctx, username)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string) int); ok {
		r2 = returnFunc(ctx, username)
	} else {
		r2 = ret.Get(2).(int)
	}
	if returnFunc, ok := ret.Get(3).(func(context.Context, string) error); ok {
		r3 = returnFunc(ctx, username)
	} else {
		r3 = ret.Error(3)
	}
	return r0, r1, r2, r3
}

// MockRateLimitRepository_CheckLoginRateLimit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckLoginRateLimit'
type MockRateLimitRepository_CheckLoginRateLimit_Call struct {
	*mock.Call
}

// CheckLoginRateLimit is a helper method to define mock.On call
//   - ctx
//   - username
func (_e *MockRateLimitRepository_Expecter) CheckLoginRateLimit(ctx interface{}, username interface{}) *MockRateLimitRepository_CheckLoginRateLimit_Call {
	return &MockRateLimitRepository_CheckLoginRateLimit_Call{Call: _e.mock.On("CheckLoginRateLimit", ctx, username)}
}

func (_c *MockRateLimitRepository_CheckLoginRateLimit_Call) Run(run func(ctx context.Context, username string)) *MockRateLimitRepository_CheckLoginRateLimit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRateLimitRepository_CheckLoginRateLimit_Call) Return(b bool, n int, n1 int, err error) *MockRateLimitRepository_CheckLoginRateLimit_Call {
	_c.Call.Return(b, n, n1, err)
	return _c
}

func (_c *MockRateLimitRepository_CheckLoginRateLimit_Call) RunAndReturn(run func(ctx context.Context, username string) (bool, int, int, error)) *MockRateLimitRepository_CheckLoginRateLimit_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUserRepository creates a new instance of MockUserRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUserRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUserRepository {
	mock := &MockUserRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUserRepository is an autogenerated mock type for the UserRepository type
type MockUserRepository struct {
	mock.Mock
}

type MockUserRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUserRepository) EXPECT() *MockUserRepository_Expecter {
	return &MockUserRepository_Expecter{mock: &_m.Mock}
}

// CreateUser provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) CreateUser(ctx context.Context, user *models.User) error {
	ret := _mock.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *models.User) error); ok {
		r0 = returnFunc(ctx, user)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockUserRepository_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type MockUserRepository_CreateUser_Call struct {
	*mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - ctx
//   - user
func (_e *MockUserRepository_Expecter) CreateUser(ctx interface{}, user interface{}) *MockUserRepository_CreateUser_Call {
	return &MockUserRepository_CreateUser_Call{Call: _e.mock.On("CreateUser", ctx, user)}
}

func (_c *MockUserRepository_CreateUser_Call) Run(run func(ctx context.Context, user *models.User)) *MockUserRepository_CreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.User))
	})
	return _c
}

func (_c *MockUserRepository_CreateUser_Call) Return(err error) *MockUserRepository_CreateUser_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockUserRepository_CreateUser_Call) RunAndReturn(run func(ctx context.Context, user *models.User) error) *MockUserRepository_CreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByEmail provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) GetUserByEmail(ctx context.Context, email string) (*models.User, error) {
	ret := _mock.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByEmail")
	}

	var r0 *models.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*models.User, error)); ok {
		return returnFunc(ctx, email)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *models.User); ok {
		r0 = returnFunc(ctx, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, email)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserRepository_GetUserByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByEmail'
type MockUserRepository_GetUserByEmail_Call struct {
	*mock.Call
}

// GetUserByEmail is a helper method to define mock.On call
//   - ctx
//   - email
func (_e *MockUserRepository_Expecter) GetUserByEmail(ctx interface{}, email interface{}) *MockUserRepository_GetUserByEmail_Call {
	return &MockUserRepository_GetUserByEmail_Call{Call: _e.mock.On("GetUserByEmail", ctx, email)}
}

func (_c *MockUserRepository_GetUserByEmail_Call) Run(run func(ctx context.Context, email string)) *MockUserRepository_GetUserByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUserRepository_GetUserByEmail_Call) Return(user *models.User, err error) *MockUserRepository_GetUserByEmail_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *MockUserRepository_GetUserByEmail_Call) RunAndReturn(run func(ctx context.Context, email string) (*models.User, error)) *MockUserRepository_GetUserByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserById provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) GetUserById(ctx context.Context, id uuid.UUID) (*models.User, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetUserById")
	}

	var r0 *models.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*models.User, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *models.User); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserRepository_GetUserById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserById'
type MockUserRepository_GetUserById_Call struct {
	*mock.Call
}

// GetUserById is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *MockUserRepository_Expecter) GetUserById(ctx interface{}, id interface{}) *MockUserRepository_GetUserById_Call {
	return &MockUserRepository_GetUserById_Call{Call: _e.mock.On("GetUserById", ctx, id)}
}

func (_c *MockUserRepository_GetUserById_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockUserRepository_GetUserById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockUserRepository_GetUserById_Call) Return(user *models.User, err error) *MockUserRepository_GetUserById_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *MockUserRepository_GetUserById_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (*models.User, error)) *MockUserRepository_GetUserById_Call {
	_c.Call.Return(run)
	return _c
}
